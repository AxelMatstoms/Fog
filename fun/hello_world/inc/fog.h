// Hi!
// This file is automatically generated C-bindings for the Fog engine,
// if you are planning on editing this, it will probably be overwritten
// on the next compilation. So maybe don't put stuff in here?

#ifdef __cplusplus
#define FOG_IMPORT extern "C"
#else
#define FOG_IMPORT
#endif

#include <stdint.h>
#include <stdarg.h>
#ifndef __cplusplus
#define bool int
#define true 1
#define false 0
#endif
#define FLOAT_EQ_MARGIN 0.0000001

typedef int8_t s8;

typedef int16_t s16;

typedef int32_t s32;

typedef uint8_t u8;

typedef uint16_t u16;

typedef uint32_t u32;

typedef float f32;

typedef double f64;

typedef long long s64;  // We assume these are a thing.

typedef unsigned long long u64;  // We assume these are a thing.

typedef f32 real;  // Type used in vectors.

struct Vec2 {
    union {
        struct {
            real x, y;
        };
        real _[2];
    };
#ifdef __cplusplus
    Vec2 operator-() const { return {-x, -y}; }

    Vec2 operator+(Vec2 other) const { return {other.x + x, y + other.y}; }

    Vec2 operator-(Vec2 other) const { return {x - other.x, y - other.y}; }

    Vec2 operator*(real scaler) const { return {x * scaler, y * scaler}; }

    Vec2 operator/(real scaler) const {
        real divisor = 1.0f / scaler;
        return {x * divisor, y * divisor};
    }

    void operator+=(Vec2 other) {
        x += other.x;
        y += other.y;
    }

    void operator-=(Vec2 other) {
        x -= other.x;
        y -= other.y;
    }

    void operator*=(real scaler) { *this = (*this) * scaler; }

    void operator/=(real scaler) { *this = (*this) / scaler; }

    bool operator==(Vec2 other) {
        return (x - other.x) * (x - other.x) < FLOAT_EQ_MARGIN &&
               (y - other.y) * (y - other.y) < FLOAT_EQ_MARGIN;
    }
#endif
};

struct Vec3 {
    union {
        struct {
            real x, y, z;
        };
        real _[3];
    };
#ifdef __cplusplus
    Vec3 operator-() { return {-x, -y, -z}; }

    Vec3 operator+(Vec3 other) {
        return {x + other.x, y + other.y, z + other.z};
    }

    Vec3 operator-(Vec3 other) {
        return {x - other.x, y - other.y, z - other.z};
    }

    Vec3 operator*(real scaler) { return {x * scaler, y * scaler, z * scaler}; }

    Vec3 operator/(real scaler) {
        real divisor = 1.0f / scaler;
        Vec3 result = {x * divisor, y * divisor, z * divisor};
        return result;
    }

    void operator+=(Vec3 other) {
        x += other.x;
        y += other.y;
        z += other.z;
    }

    void operator-=(Vec3 other) {
        x -= other.x;
        y -= other.y;
        z -= other.z;
    }

    void operator*=(real scaler) { *this = (*this) * scaler; }

    void operator/=(real scaler) { *this = (*this) / scaler; }

    bool operator==(Vec3 other) {
        return (x - other.x) * (x - other.x) < FLOAT_EQ_MARGIN &&
               (y - other.y) * (y - other.y) < FLOAT_EQ_MARGIN &&
               (z - other.z) * (z - other.z) < FLOAT_EQ_MARGIN;
    }
#endif
};

struct Vec4 {
    union {
        struct {
            real x, y, z, w;
        };
        real _[4];
    };
#ifdef __cplusplus
    Vec4 operator-() { return {-x, -y, -z, -w}; }

    Vec4 operator+(Vec4 other) {
        return {x + other.x, y + other.y, z + other.z, w + other.w};
    }

    Vec4 operator-(Vec4 other) {
        return {x - other.x, y - other.y, z - other.z, w - other.w};
    }

    Vec4 operator*(real scaler) {
        return {x * scaler, y * scaler, z * scaler, w * scaler};
    }

    Vec4 operator/(real scaler) {
        real divisor = 1.0f / scaler;
        return {x * divisor, y * divisor, z * divisor, w * divisor};
    }

    void operator+=(Vec4 other) {
        x += other.x;
        y += other.y;
        z += other.z;
        w += other.w;
    }

    void operator-=(Vec4 other) {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        w += other.w;
    }

    void operator*=(real scaler) { *this = (*this) * scaler; }

    void operator/=(real scaler) { *this = (*this) / scaler; }

    bool operator==(Vec4 other) {
        return (x - other.x) * (x - other.x) < FLOAT_EQ_MARGIN &&
               (y - other.y) * (y - other.y) < FLOAT_EQ_MARGIN &&
               (z - other.z) * (z - other.z) < FLOAT_EQ_MARGIN &&
               (w - other.w) * (w - other.w) < FLOAT_EQ_MARGIN;
    }
#endif
};

typedef Vec4(*ProgressFuncVec4)(Vec4, f32, Vec4, f32, f32);

Vec2 V2(real x, real y);

Vec3 V3(real x, real y, real z);

Vec4 V4(real x, real y, real z, real w);

typedef u64 AssetID;

typedef void(*FogCallback)(void);

typedef u32 Layer;

typedef u32 ShapeID;

typedef void(*Callback)(f32, f32, f32, void *);

typedef f32(*ProgressFuncF32)(f32, f32, f32, f32, f32);

typedef u32 InputCode;

typedef u32 Name;

struct Body {
    ShapeID shape;
    Layer layer;

    Vec2 offset;

    // This is just for static rotation. So the
    // bodies can be oriented. No rotational forces
    // are applied.
    f32 rotation;
    Vec2 position;
    Vec2 scale;

    Vec2 velocity;
    Vec2 acceleration;
    Vec2 force;

    f32 inverse_mass;
    f32 damping;
    f32 bounce;
};

struct Overlap {
    Body *a, *b;
    f32 depth;
    Vec2 normal; // Allways points towards a.
    bool is_valid;

#ifdef FOG_ENGINE
    operator bool() const { return is_valid; }
#endif
};

enum At {
    PRE_UPDATE,
    POST_UPDATE,
    PRE_DRAW,
    POST_DRAW,

    COUNT,
};

struct LogicID {
    At at;
    s16 slot;
    u8 gen;

#ifdef __cplusplus
    bool operator==(LogicID &other) const {
        return at == other.at
            && gen == other.gen
            && slot == other.slot;
    }
#endif
};

struct Span {
    // TODO(ed): Maybe add different kinds of randomizations.
    f32 min, max;

#ifdef FOG_ENGINE
    f32 random() {
        return random_real(min, max);
    }
#endif
};

enum Player {
    NONE = 0b0000,

    P1 = 0b0001,
    P2 = 0b0010,
    P3 = 0b0100,
    P4 = 0b1000,

    // Max number of players.
    NUM = 4,

    ANY = 0b1111,
};

InputCode key_to_input_code(s32 scancode);

InputCode axis_to_input_code(s32 scancode, s32 which);

InputCode button_to_input_code(s32 scancode, s32 which);

struct AudioID {
    u8 gen;
    u16 slot;
};

constexpr f32 AUDIO_DEFAULT_GAIN = 0.2;

constexpr f32 AUDIO_DEFAULT_VARIANCE = 0.01;

///* Camera struct
// The camera struct is how a camera is controlled. This struct can
// give you fine grain camera control.
struct Camera {
    Vec2 position;
    Vec2 offset;
    f32 zoom;
    f32 aspect_ratio; // height / width
    f32 _padding_[2];
};

struct Window {
    f32 width;
    f32 height;
    f32 aspect_ratio;
    f32 _padding_;
};

#define MAX_NUM_SUB_SPRITES 32
struct ParticleSystem {

    u32 num_sprites;
    u32 layer;
    AssetID sprites[MAX_NUM_SUB_SPRITES];

    // Utility
    u32 head;
    u32 tail;
    u32 max_num_particles;
#ifdef FOG_ENGINE
    Particle *particles = nullptr;
    Util::MemoryArena *memory;
#else
    void *particles;
    void *memory;
#endif

    bool relative;
    bool keep_alive;
    bool one_color;
    bool one_alpha;
    bool one_size;
    bool drop_oldest;
    Vec2 position;

    // Spawning
    Span alive_time;

    Span rotation;
    Span angular_velocity;

    Span position_x;
    Span position_y;
    Span velocity_dir;
    Span velocity;
    Span damping;
    Span acceleration_dir;
    Span acceleration;

    Span spawn_size;
    Span spawn_size_deriv;
    Span die_size;
    Span die_size_deriv;

    ProgressFuncF32 progress_func_size;

    Span width;
    Span height;

    Span spawn_red;
    Span spawn_green;
    Span spawn_blue;
    Span spawn_alpha;
    Span spawn_color_deriv;

    Span die_red;
    Span die_green;
    Span die_blue;
    Span die_alpha;
    Span die_color_deriv;

    ProgressFuncVec4 progress_func_color;
};

enum MarkerID {
    MAIN,
    INPUT,
    RENDER,
    TEXT,

    ENTITY_UPDATE,
    ENTITY_DRAW,
    ENTITY_DEFRAG,

    AUDIO,
    AUDIO_SOURCES,
    AUDIO_EFFECTS,

    NUMBER_OF_MARKERS, // Don't write anything after this.
};

const AssetID ASSET_ID_NO_ASSET = 0xFFFFFFFF;

const f32 FOREVER = -1;

const f32 ONCE = 0;

FOG_IMPORT AssetID fog_asset_fetch_id(const char *str);
FOG_IMPORT void fog_test_func();
FOG_IMPORT void fog_init(int argc, char **argv);
FOG_IMPORT void fog_run(FogCallback update, FogCallback draw);
FOG_IMPORT ShapeID fog_physics_add_shape(u32 points_length, Vec2 *points);
FOG_IMPORT Body fog_physics_create_body(ShapeID shape_id, f32 mass = 1.0f, u32 layer=0xFFFFFFFF, f32 bounce = 0.1f, f32 damping = 0.1f);
FOG_IMPORT void fog_physics_center_body(Body *body);
FOG_IMPORT void fog_physics_swap_shape(Body *body, ShapeID shape);
FOG_IMPORT Overlap fog_physics_check_overlap(Body *body_a, Body *body_b);
FOG_IMPORT void fog_physics_solve(Overlap overlap);
FOG_IMPORT bool fog_physics_point_in_box(Vec2 p, Vec2 center, Vec2 radius, f32 rotation);
FOG_IMPORT bool fog_physics_point_in_box_region(Vec2 p, Vec2 min, Vec2 max);
FOG_IMPORT void fog_physics_integrate(Body *body, f32 delta);
FOG_IMPORT void fog_physics_debug_draw_body(Body *body);
FOG_IMPORT LogicID fog_logic_add_callback(At at, Callback callback, f32 start = 0.0, f32 end = ONCE, f32 spacing = 0.0, void *aux=nullptr);
FOG_IMPORT void fog_logic_update_callback(LogicID id, Callback callback, f32 start, f32 end, f32 spacing, void *aux=nullptr);
FOG_IMPORT void fog_logic_remove_callback(LogicID id);
FOG_IMPORT f32 fog_logic_now();
FOG_IMPORT f32 fog_logic_delta();
FOG_IMPORT bool fog_inside(Vec2 p1, Vec2 p2, Vec2 q);
FOG_IMPORT float fog_winding_direction(Vec2 p1, Vec2 p2, Vec2 p3);
FOG_IMPORT f32 fog_std_progress_func_f32(f32 start_value, f32 start_slope, f32 end_value, f32 end_slope, f32 progress);
FOG_IMPORT Vec4 fog_std_progress_func_vec4(Vec4 start_value, f32 start_slope, Vec4 end_value, f32 end_slope, f32 progress);
FOG_IMPORT real fog_dot_v2(Vec2 a, Vec2 b);
FOG_IMPORT real fog_length_squared_v2(Vec2 a);
FOG_IMPORT real fog_length_v2(Vec2 a);
FOG_IMPORT real fog_distance_v2(Vec2 a, Vec2 b);
FOG_IMPORT Vec2 fog_normalize_v2(Vec2 a);
FOG_IMPORT Vec2 fog_hadamard_v2(Vec2 a, Vec2 b);
FOG_IMPORT Vec2 fog_inverse_v2(Vec2 a);
FOG_IMPORT Vec2 fog_rotate_ccw_v2(Vec2 p);
FOG_IMPORT Vec2 fog_rotate_v2(Vec2 p, real angle);
FOG_IMPORT real fog_angle_v2(Vec2 p);
FOG_IMPORT real fog_look_at_v2(Vec2 from, Vec2 to);
FOG_IMPORT Vec2 fog_neg_v2(Vec2 self);
FOG_IMPORT Vec2 fog_add_v2(Vec2 self, Vec2 other);
FOG_IMPORT Vec2 fog_sub_v2(Vec2 self, Vec2 other);
FOG_IMPORT Vec2 fog_mul_v2(Vec2 self, real scaler);
FOG_IMPORT Vec2 fog_div_v2(Vec2 self, real scaler);
FOG_IMPORT bool fog_eq_v2(Vec2 self, Vec2 other);
FOG_IMPORT real fog_dot_v3(Vec3 a, Vec3 b);
FOG_IMPORT Vec3 fog_cross_v3(Vec3 a, Vec3 b);
FOG_IMPORT real fog_length_cubed_v3(Vec3 a);
FOG_IMPORT real fog_length_squared_v3(Vec3 a);
FOG_IMPORT real fog_length_v3(Vec3 a);
FOG_IMPORT Vec3 fog_normalize_v3(Vec3 a);
FOG_IMPORT Vec3 fog_neg_v3(Vec3 self);
FOG_IMPORT Vec3 fog_add_v3(Vec3 self, Vec3 other);
FOG_IMPORT Vec3 fog_sub_v3(Vec3 self, Vec3 other);
FOG_IMPORT Vec3 fog_mul_v3(Vec3 self, real scaler);
FOG_IMPORT Vec3 fog_div_v3(Vec3 self, real scaler);
FOG_IMPORT bool fog_eq_v3(Vec3 self, Vec3 other);
FOG_IMPORT real fog_dot_v4(Vec4 a, Vec4 b);
FOG_IMPORT real fog_length_squared_v4(Vec4 a);
FOG_IMPORT real fog_length_v4(Vec4 a);
FOG_IMPORT Vec4 fog_normalize_v4(Vec4 a);
FOG_IMPORT Vec4 fog_neg_v4(Vec4 self);
FOG_IMPORT Vec4 fog_add_v4(Vec4 self, Vec4 other);
FOG_IMPORT Vec4 fog_sub_v4(Vec4 self, Vec4 other);
FOG_IMPORT Vec4 fog_mul_v4(Vec4 self, real scaler);
FOG_IMPORT Vec4 fog_div_v4(Vec4 self, real scaler);
FOG_IMPORT bool fog_eq_v4(Vec4 self, Vec4 other);
FOG_IMPORT bool fog_random_bit();
FOG_IMPORT u32 fog_random_int();
FOG_IMPORT f32 fog_random_real(f32 low=0.0, f32 high=1.0);
FOG_IMPORT Vec2 fog_random_unit_vec2();
FOG_IMPORT Vec3 fog_random_unit_vec3();
FOG_IMPORT Name fog_input_request_name(u32 num=1);
FOG_IMPORT bool fog_input_using_controller();
FOG_IMPORT void fog_input_start_text_input();
FOG_IMPORT void fog_input_stop_text_input();
FOG_IMPORT bool fog_input_edit_string(char *text, u32 max_length);
FOG_IMPORT bool fog_input_add(InputCode code, Name name, Player player=P1);
FOG_IMPORT bool fog_input_triggered(Name name, Player player=ANY);
FOG_IMPORT bool fog_input_pressed(Name name, Player player=ANY);
FOG_IMPORT bool fog_input_released(Name name, Player player=ANY);
FOG_IMPORT bool fog_input_down(Name name, Player player=ANY);
FOG_IMPORT f32 fog_input_value(Name name, Player player=ANY);
FOG_IMPORT bool fog_input_super_pressed(Name name, Player player=ANY);
FOG_IMPORT Vec2 fog_input_mouse_position();
FOG_IMPORT Vec2 fog_input_mouse_move();
FOG_IMPORT Vec2 fog_input_screen_to_world(Vec2 p, u32 camera_id=0);
FOG_IMPORT Vec2 fog_input_world_mouse_position(u32 camera_id=0);
FOG_IMPORT Vec2 fog_input_normalized_mouse_position();
FOG_IMPORT Vec2 fog_input_world_mouse_move(u32 camera_id = 0);
FOG_IMPORT u32 fog_input_mouse_depth();
FOG_IMPORT void fog_input_eat_mouse();
FOG_IMPORT Vec2 fog_input_mouse_scroll();
FOG_IMPORT bool fog_input_mouse_triggered(u8 button);
FOG_IMPORT bool fog_input_mouse_pressed(u8 button);
FOG_IMPORT bool fog_input_mouse_released(u8 button);
FOG_IMPORT bool fog_input_mouse_down(u8 button);
FOG_IMPORT AudioID fog_mixer_play_sound(u32 channel_id, AssetID asset_id, f32 pitch = 1.0, f32 gain = AUDIO_DEFAULT_GAIN, f32 pitch_variance = AUDIO_DEFAULT_VARIANCE, f32 gain_variance = AUDIO_DEFAULT_VARIANCE, bool loop = false);
FOG_IMPORT AudioID fog_mixer_play_sound_at(u32 channel_id, AssetID asset_id, Vec2 position, f32 pitch = 1.0, f32 gain = AUDIO_DEFAULT_GAIN, f32 pitch_variance = AUDIO_DEFAULT_VARIANCE, f32 gain_variance = AUDIO_DEFAULT_VARIANCE, bool loop = false);
FOG_IMPORT void fog_mixer_stop_sound(AudioID id);
FOG_IMPORT void fog_mixer_channel_set_delay(u32 channel_id, f32 feedback, f32 len_seconds, f32 in_seconds = 1.0);
FOG_IMPORT void fog_mixer_channel_set_lowpass(u32 channel_id, f32 weight, f32 in_seconds = 1.0);
FOG_IMPORT void fog_mixer_channel_set_highpass(u32 channel_id, f32 weight, f32 in_seconds = 1.0);
FOG_IMPORT Camera *fog_renderer_fetch_camera(u32 camera_id=0);
FOG_IMPORT Window *fog_renderer_get_window();
FOG_IMPORT f32 fog_renderer_get_window_width();
FOG_IMPORT f32 fog_renderer_get_window_height();
FOG_IMPORT f32 fog_renderer_get_window_aspect_ratio();
FOG_IMPORT void fog_renderer_camera_shake(Camera *camera, Vec2 shake);
FOG_IMPORT Camera fog_renderer_camera_lerp(Camera camera_a, Camera camera_b, f32 lerp);
FOG_IMPORT Camera fog_renderer_camera_smooth(Camera camera_a, Camera camera_b, f32 slerp);
FOG_IMPORT Camera fog_renderer_camera_fit(u32 num_points, Vec2 *points, f32 border=0.0);
FOG_IMPORT void fog_renderer_camera_fit_inplace(Camera *camera, u32 num_points, Vec2 *points, f32 border=0.0);
FOG_IMPORT void fog_renderer_debug_camera(u32 camera_id=0);
FOG_IMPORT void fog_renderer_turn_on_camera(u32 camera_id);
FOG_IMPORT void fog_renderer_turn_off_camera(u32 camera_id);
FOG_IMPORT void fog_renderer_push_sprite_rect(u32 layer, Vec2 position, Vec2 dimension, f32 angle, AssetID texture, Vec2 uv_min, Vec2 uv_dimension, Vec4 color = V4(1, 1, 1, 1));
FOG_IMPORT void fog_renderer_push_rectangle(u32 layer, Vec2 position, Vec2 dimension, Vec4 color = V4(1, 1, 1, 1));
FOG_IMPORT void fog_renderer_push_line_gradient(u32 layer, Vec2 start, Vec2 end, Vec4 start_color, Vec4 end_color, f32 thickness = 0.02);
FOG_IMPORT void fog_renderer_push_line(u32 layer, Vec2 start, Vec2 end, Vec4 color, f32 thickness = 0.01);
FOG_IMPORT void fog_renderer_push_point(u32 layer, Vec2 point, Vec4 color, f32 size = 0.015);
FOG_IMPORT void fog_renderer_set_window_position(int x, int y);
FOG_IMPORT Vec2 fog_renderer_get_window_position();
FOG_IMPORT void fog_renderer_set_window_size(int w, int h);
FOG_IMPORT Vec2 fog_renderer_get_window_size();
FOG_IMPORT void fog_renderer_set_window_title(const char *title);
FOG_IMPORT void fog_renderer_set_fullscreen(bool fullscreen);
FOG_IMPORT void fog_renderer_toggle_fullscreen();
FOG_IMPORT bool fog_renderer_is_fullscreen();
FOG_IMPORT ParticleSystem fog_renderer_create_particle_system(u32 layer, u32 num_particles, Vec2 position);
FOG_IMPORT void fog_renderer_destroy_particle_system(ParticleSystem *system);
FOG_IMPORT void fog_renderer_particle_spawn(ParticleSystem *self, u32 num_particles=1);
FOG_IMPORT void fog_renderer_particle_update(ParticleSystem *self, f32 delta);
FOG_IMPORT void fog_renderer_particle_draw(ParticleSystem *self);
FOG_IMPORT void fog_renderer_particle_clear(ParticleSystem *self);
FOG_IMPORT void fog_renderer_particle_add_sprite(ParticleSystem *self, AssetID sprite);
FOG_IMPORT Vec2 fog_renderer_messure_text(const char *string, f32 size, AssetID font_id);
FOG_IMPORT void fog_renderer_draw_text(const char *string, f32 x, f32 y, f32 size, AssetID font_id, f32 alignment = 0.0, Vec4 color = V4(1, 1, 1, 1), f32 edge = 0.2, bool border = false);
FOG_IMPORT char *fog_util_format(const char *fmt, va_list args);
FOG_IMPORT u8 fog_util_utf8_size(const char *c);
FOG_IMPORT bool fog_util_utf8_is_first_char(const char *c);
FOG_IMPORT bool fog_util_utf8_insert_glyph(char *to, const char *from, u32 length);
FOG_IMPORT char *fog_util_utf8_advance(char *c);
FOG_IMPORT void *fog_util_temporary_bytes(u64 num);
FOG_IMPORT void fog_util_copy_bytes(const void *from, void *to, u64 size);
FOG_IMPORT void fog_util_allow_allocation();
FOG_IMPORT void fog_util_allow_all_allocations();
FOG_IMPORT bool fog_util_begin_tweak_section(const char *name, bool *active);
FOG_IMPORT void fog_util_end_tweak_section(bool *active);
FOG_IMPORT bool fog_util_tweak_bool(const char *name, bool *value);
FOG_IMPORT bool fog_util_tweak_s32(const char *name, s32 *value);
FOG_IMPORT bool fog_util_tweak_u32(const char *name, u32 *value);
FOG_IMPORT bool fog_util_tweak_f32(const char *name, f32 *value, f32 modifier=1.0);
FOG_IMPORT bool fog_util_tweak_vec2(const char *name, Vec2 *value, f32 modifier=1.0);
FOG_IMPORT bool fog_util_tweak_span(const char *name, Span *value, f32 modifier=1.0);
#undef FOG_IMPORT